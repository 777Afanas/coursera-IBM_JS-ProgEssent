// массив содержит различные цветовые значения в строках, представляя цвета для карточек 
// в игре на запоминание. Эти цвета создают пары для игры. 
const colors = ['red', 'blue', 'green', 'purple', 'orange', 'pink', 'red', 'blue', 'green', 'purple', 'orange', 'pink'];
// const colors = ['red', 'blue', 'green', 'purple', 'orange', 'pink'];

// Инициализированный путем перемешивания и присоединения массива ‘colors’, этот массив ‘cards’ 
// содержит цветовые значения для карточек в игре. Функция shuffle использует алгоритм Фишера-Йетса 
// для рандомизации порядка цветов, а затем дублирует эти цвета для создания пар, 
// формируя набор карточек для игрового процесса. 
let cards = shuffle(colors.concat(colors));

// переменная служит временным хранилищем для текущих выбранных карточек 
// во время игры. Когда игрок нажимает на карточку, она добавляется 
// в этот массив для возможности сравнения пар.
let selectedCards = [];

// переменная отслеживает счет игрока на протяжении всей игры. 
// Счет увеличивается каждый раз, когда игрок успешно находит пару карточек. 
// Он обновляется и отображается, чтобы отразить прогресс и результаты игрока. 
let score = 0;

// переменная представляет оставшееся время для игрока, чтобы завершить игру. 
// Изначально установлена на определенную продолжительность, 
// она отсчитывает время по мере прогресса игры. 
// Когда она достигает нуля, игра заканчивается.
let timeLeft = 30;

// переменная управляет таймером игры. Она используется для контроля 
// механизма обратного отсчета для продолжительности игры. 
// Интервал постоянно уменьшает переменную ‘timeLeft’, обновляя отображаемое время 
// и вызывая окончание игры, когда время истекает. 
let gameInterval;

// переменная присваивается HTML-элементу с ID ‘startbtn’. Обычно она представляет 
// элемент кнопки, предназначенный для начала или перезапуска игры при нажатии. 
// позволяет коду JavaScript получать доступ к этому конкретному элементу кнопки и манипулировать им.
const startbtn = document.getElementById('startbtn');

// переменная присваивается HTML-элементу с ID ‘game-container’; она ссылается на div или контейнерный элемент, 
// который динамически генерирует карточки для игры на запоминание.  
// позволяет JS манипулировать или добавлять дочерние элементы (карточки) внутри этого контейнера. 
const gameContainer = document.getElementById('game-container'); 

// переменная представляет HTML-элемент с ID ‘score’. связана с параграфом или элементом span, 
// отображающим счет игрока во время игры. JS может обновлять отображаемый счет, 
// манипулируя содержимым этого конкретного элемента.
const scoreElement = document.getElementById('score'); 

// переменная ссылается на HTML-элемент, идентифицированный по ID ‘timer’. 
// предположительно, связана с параграфом или элементом span, 
// который отображает оставшееся время для игрока, чтобы завершить игру. 
// JS может обновлять этот элемент, чтобы отразить обратный отсчет 
// и уведомить игрока о времени, оставшемся до завершения.
const timerElement = document.getElementById('timer');

// ФУНКЦИЯ отвечает за динамическое создание элементов карты в 
// контейнере игры на основе массива 'cards', который содержит 
// значения цветов для карт, динамически создает элементы карт внутри div с классом game-container. 
// function generateCards() {
    
// // цикл 'for…of' для перебора каждого элемента (цвета) в массиве 'cards' (для каждого цвета в массиве) 
//     for (const color of cards) {
// // создается новый HTML элемент div, который представляет карту в игре.
//         const card = document.createElement('div');
// // К 'div' добавляется класс 'card', который может содержать CSS стили или правила для оформления элементов карт.        
//         card.classList.add('card');

// // Атрибут 'dataset.color' устанавливается в текущее значение цвета из массива 'cards'. 
// // Он представляет скрытый цвет карты до тех пор, пока игрок не нажмет на нее.        
//         card.dataset.color = color;

// // Текстовое содержимое карты изначально устанавливается на вопросительный знак ('?') 
// // что означает - цвет карты скрыт, пока игрок не нажмет на нее.        
//         card.textContent = '?';
// // добавляет каждый элемент карты в интерфейс игры внутри назначенного контейнера.        
//         gameContainer.appendChild(card);
//     }
// }
function generateCards() {       
        for (const color of cards) {     
            const card = document.createElement('div');            
            card.classList.add('card');             
            card.dataset.color = color;            
            card.textContent = '?';            
            gameContainer.appendChild(card);
        }
    } 


// отвечает за перемешивание элементов массива в случайном порядке. 
// использует алгоритм перемешивания Фишера-Йетса (рандомизация порядка элементов в массиве). 
// принимает как аргумент массив, который содержит еще не перемешанные элементы.
// function shuffle(array) {
//     // цикл проходит по массиву, начиная с последнего индекса
//     // и продолжается, пока не завершится перебор, перемешивая элементы по пути.
//     // после завершения цикла - возвращается массив с элементами в случайном порядке.
//         for (let i = array.length - 1; i > 0; i--) {
//         // В каждой итерации генерируетcя случайный индекс 'j',          
//         // который представляет случайный индекс внутри массива.
//             const j = Math.floor(Math.random() * (i + 1)); 
//         // элементы по индексам 'i' и 'j' с помощью деструктурирующего присваивания
//         // меняются местами (меняются местами значения на позициях 'i' и 'j' без необходимости временной переменной)
//             [array[i], array[j]] = [array[j], array[i]];
//         }
//         return array;
// }

// // управляет логикой, когда пользователь нажимает на карту в игре на соответствие памяти. 
// function handleCardClick(event) { 
//     // получение элемента, который вызвал событие (нажатую карту) и присваивание его переменной 'card'.
//         const card = event.target; 
// // проверка, является ли нажатый элемент картой и если он уже совпал (любое из условий истинно) - 
// // в противном случае (элемент не является картой / уже совпал) - управление возвращается, 
// // игнорируя любые дальнейшие действия для этого нажатия.
//         if (!card.classList.contains('card') || card.classList.contains('matched')) {
//             return;
//         }
// // устанавливает текстовое содержимое нажатой карты на значение, хранящееся в её 'dataset.color'. 
// // Это действие открывает цвет карты, изменяя текстовое содержимое на значение цвета.
//         card.textContent = card.dataset.color; 
// //Изменяет фоновый цвет карты (чтоб соответствовал открытому цвету), обработка выбранных карт:
//         card.style.backgroundColor = card.dataset.color;
// // ообавляет нажатую карту в массив 'selectedCards', указывая, что это одна из карт, выбранных игроком.
//         selectedCards.push(card);
// // Проверка на совпадения - были ли выбраны две карты, если ДА
// // (две карты выбраны) - используется 'setTimeout()' для задержки выполнения 
// // функции 'checkMatch()' на 500 миллисекунд - задержка позволяет игроку 
// // увидеть обе выбранные карты перед их сравнением.
//         if (selectedCards.length === 2) {
//             setTimeout(checkMatch, 500);
//         }
// }

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

// управляет логикой, когда пользователь нажимает на карту в игре на соответствие памяти. 
function handleCardClick(event) {
    const card = event.target;
    if (!card.classList.contains('card') || card.classList.contains('matched')) {
        return;
    }
    card.textContent = card.dataset.color;
    card.style.backgroundColor = card.dataset.color;
    selectedCards.push(card);
    if (selectedCards.length === 2) {
        setTimeout(checkMatch, 500);
    }
}

// Цель события с помощью const card = event.target;: Эта строка получает элемент, который вызвал событие (в данном случае, нажатую карту) и присваивает его переменной 'card'.
// Проверка карты: if (!card.classList.contains('card') || card.classList.contains('matched')) { return; } Эта 'if' инструкция проверяет, является ли нажатый элемент картой и если он уже совпал. Если любое из условий истинно:
// Если элемент не является картой или уже совпал, функция возвращает управление, игнорируя любые дальнейшие действия для этого нажатия.// Открытие карты:
// card.textContent = card.dataset.color;: Устанавливает текстовое содержимое нажатой карты на значение, хранящееся в её 'dataset.color'. Это действие открывает цвет карты, изменяя текстовое содержимое на значение цвета.
// card.style.backgroundColor = card.dataset.color;: Изменяет фоновый цвет карты, чтобы он соответствовал открытому цвету.
// Обработка выбранных карт:
// selectedCards.push(card);: Добавляет нажатую карту в массив 'selectedCards', указывая, что это одна из карт, выбранных игроком.
// Проверка на совпадения:
// if (selectedCards.length === 2) { setTimeout(checkMatch, 500); }: Проверяет, были ли выбраны две карты. Если выбраны две карты, используется 'setTimeout()' для задержки выполнения функции 'checkMatch()' на 500 миллисекунд. Эта краткая задержка позволяет игроку увидеть обе выбранные карты перед их сравнением.


// // оценивает, совпадают ли две выбранные карты друг с другом в игре на соответствие памяти. 
// function checkMatch(){ 
// // использует деструктуризацию массива, чтобы присвоить первые два элемента 
// // массива 'selectedCards' переменным 'card1' и 'card2'. 
// // эти переменные представляют две карты, выбранные игроком для сравнения.
//     const [card1, card2] = selectedCards;
// // проверка совпадает ли значение цвета - в атрибуте 'dataset.color' - 'card1', с цветом  - 'card2'.
//     if (card1.dataset.color === card2.dataset.color) { 
// // при совпадении: класс 'matched' добавляется обеим картам, отмечая их как совпадающие пары в игре.        
//         card1.classList.add('matched');
//         card2.classList.add('matched');
// // Увеличивает 'score' на 2 очка, так как игрок успешно подобрал пару.
//         score += 2;
// // Обновляет 'scoreElement.textContent', чтобы отобразить обновленный счет игроку.
//         scoreElement.textContent = `Score: ${score}`;         
//     } else { 
// //цвета двух выбранных карт не совпадают, текстовое содержимое обеих карт сбрасывается 
// // на вопросительный знак ('?'), скрывая их цвета снова.    
//         card1.textContent = '?';
//         card2.textContent = '?'; 
// // фоновый цвет обеих карт устанавливается на стандартный цвет ('#ddd'), 
// // предоставляя визуальный сигнал  -  выбранные карты не совпали.      
//         card1.style.backgroundColor = '#ddd';
//         card2.style.backgroundColor = '#ddd'; 
//     } 

// // oчищает массив 'selectedCards', чтобы сбросить его для следующего набора выборок карт. 
// // Это действие гарантирует, что игрок может выбрать две новые карты после сравнения.
//     selectedCards = [];
// } 

function checkMatch() {
    const [card1, card2] = selectedCards;
    if (card1.dataset.color === card2.dataset.color) {
        card1.classList.add('matched');
        card2.classList.add('matched');
        score += 2;
        scoreElement.textContent = `Score: ${score}`;
    } else {
        card1.textContent = '?';
        card2.textContent = '?';
        card1.style.backgroundColor = '#ddd';
        card2.style.backgroundColor = '#ddd';
    }
    selectedCards = [];
}

// ключевая часть инициализации и начала игры на соответствие памяти 
function startGame() {
    let timeLeft = 30;
    startbtn.disabled = true;
    score = 0; // сбросить счет до нуля
    scoreElement.textContent = `Score: ${score}`;
    startGameTimer(timeLeft);
    cards = shuffle(colors.concat(colors));
    selectedCards = [];
    gameContainer.innerHTML = '';
    generateCards();
    gameContainer.addEventListener('click', handleCardClick);
}

// описание функциональности: 
// Установка начального состояния игры: let timeLeft = 30; - Инициализирует переменную 'timeLeft' на 30 секунд, 
// устанавливая продолжительность игры.
// startbtn.disabled = true; - Отключает кнопку 'startbtn', чтобы предотвратить множественные инициации игры 
// одновременно, гарантируя, что в данный момент идет только одна игра. 
// score = 0;: Сбрасывает переменную 'score' до нуля, инициализируя её для новой игры. 
// scoreElement.textContent = Score: ${score};: Обновляет отображаемый счет, чтобы показать, что он сброшен до нуля для новой игры.
// Запуск таймера игры: startGameTimer(timeLeft); - Инициализирует таймер игры, отсчитывая время от указанной продолжительности 'timeLeft'.
// Подготовка карт и игровых элементов: cards = shuffle(colors.concat(colors)); - Перемешивает массив 'colors' и дублирует его, чтобы создать пары для игровых карт.
// selectedCards = [];: Очищает массив 'selectedCards', чтобы подготовить его для новых выборок карт в предстоящей игре.
// gameContainer.innerHTML = '';: Очищает контейнер игры, удаляя любые существующие карты из предыдущих игр.
// generateCards();: Генерирует новый набор карт внутри контейнера игры, вызывая функцию 'generateCards()', создавая свежую раскладку игры для игрока.
// Включение события клика по картам: gameContainer.addEventListener('click', handleCardClick); - 
// Добавляет слушатель событий к контейнеру игры, позволяя кликать по картам и вызывая 
// функцию 'handleCardClick()' для управления игровым процессом при нажатии на карты.


// управляет таймером игры, обновляя отображаемое время и обрабатывая конец игры, когда таймер достигает нуля.
function startGameTimer(timeLeft) {
    timerElement.textContent = `Time Left: ${timeLeft}`;
    gameInterval = setInterval(() => {
        timeLeft--;
        timerElement.textContent = `Time Left: ${timeLeft}`;

        if (timeLeft === 0) {
            clearInterval(gameInterval);
            let timeLeft = 30;
            alert('Игра окончена!');
            startbtn.disabled = false;
        }
    }, 1000)
}

// объяснение её работы:

// Начальное отображение: timerElement.textContent = Time Left: ${timeLeft}; - Устанавливает начальное отображение таймера, 
// чтобы показать значение 'timeLeft', указывая на оставшееся время для игры.
// Настройка интервала: gameInterval = setInterval(() => { ... }, 1000); - Запускает интервал, который вызывает функцию 
// каждую секунду (1000 миллисекунд) для обновления таймера.
// Обратный отсчет: timeLeft--; - Уменьшает переменную 'timeLeft' каждую секунду внутри интервала, 
// симулируя обратный отсчет за счет уменьшения оставшегося времени.
// Обновление отображаемого времени: timerElement.textContent = Time Left: ${timeLeft}; - Обновляет отображаемое время на HTML элементе 
// ('timerElement'), чтобы отразить обновленное значение 'timeLeft' после каждого уменьшения.
// Конец игры: if (timeLeft === 0) { ... }: Проверяет, достигло ли оставшееся время нуля.
// Если 'timeLeft' равно нулю: clearInterval(gameInterval); - Останавливает интервал, эффективно завершая таймер, ч
// тобы он больше не отсчитывал время. 
// let timeLeft = 30;: Эта строка избыточна, так как повторно объявляет 'timeLeft' в пределах этого блока, сбрасывая его до 30, но это не влияет на 'timeLeft', используемый в интервале.
// alert('Игра окончена!');: Показывает предупреждение, указывающее на то, что игра окончена, потому что был достигнут лимит времени.
// startbtn.disabled = false;: Снова включает кнопку 'startbtn', позволяя игроку начать новую игру после завершения текущей.

// Для прослушивания события клика startbtn добавляет слушатель событий к элементу 'startbtn', 
// вызывая функцию 'startGame' при нажатии на кнопку. 
startbtn.addEventListener('click', startGame);